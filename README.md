# vue-admin

> 基于vue-admin-template的二次定制脚手架，去掉了一些繁琐的东西，升级了一些包

**Live demo:** http://panjiachen.github.io/vue-admin-template
# step1
# 项目目录

固定的抽象方式： 语义化 + 增加可维护性

# 关键文件

1. package.json
    script 可执行的命令 自定义
    生产依赖 npm i axios 参与打包 运行浏览器
    开发依赖 npm i sass -D 不参与打包 开发阶段生效

2. main.js
    不写业务代码 全局初始化的事情 初始化第三方组件/样式初始化/store/router

3. 组件化的开发模式 组件树

4. vueRouter
    一级和二级如何配置

5. vuex
    1. 模块化 namespaced modules{子模块}
    2. 和数据相关的所有的操作都放到vuex中维护+组件只做一个事情触发action


# request.js + apis

1. request会产生一个实例对象给每个api函数使用 一对多的关系 request配置所有的api函数都会跟着生效

2. axios基础封装
    1. 实例化 baseURL+timeout
    2. 请求拦截器 token注入
    3. 响应拦截器 401状态判断+数据剥离

# 登录

1. 业务模式
    1. 表单基础校验
    2. 表单统一校验
    3. 后续的业务处理（调用接口-token-存入token-跳转首页-提示用户）

2. 表单校验
    1. 通过devtools查看双向绑定是否成功
    2. 对照接口文档查看和接口参数要求是否一致
    3. 校验时机实施校验和统一校验都需要

3. token管理
    1. 多模块共享 vuex维护
    2. 管理方式 vuex + cookie（localstorage保证刷新不丢失）
        cookie与ls区别
        1. 存储空间大小
        2. 是否允许后端操作
        3. 是否跟随接口发送

# step2
# 列表基础渲染
1. 实现步骤
    1. 按照接口文档请求列表封装一下（url/method/参数）
    2. data准备响应式的数据（以后端接口时机返回为主）
    3. method封装一个方法（参数的二次处理 + 调用接口 + 数据赋值）
    4. 声明周期钩子函数调用这个方法（created）
    5. 响应式数据绑定在组件上（date）
# 分页功能
1. 分页的逻辑
    页数= 总页数/单页的条数

2. 组件分好页
    传入总数： total="100"
    单页条数： pageSize="2"  默认是10

3. 点击分页交互的实现
    1. 点击时拿到当前点击的页数（父组件从子组件获取内部的数据 子串父）
        @current-change = "pageChange"
        ```js
        pageChange(page){

        }

    2. 使用当前的页数去后端要当前页的数据重新渲染到table
        ```js
        this.params.page = page
        this.getList()
        
# 状态适配
1. 场景
    后端返回的数据没法直接显示到页面中0/1 男女
2. 转化的状态码数量为2
    三元表达式
3. 转化的状态码数量大于2
    使用一个map进行映射map={}  使用map[xxx]

# 新增功能
1. 步骤
    1. 点击跳转到新的路由页面（在当前页面打开一个弹框）
    2. 准备表单项（通常只要有表单就会校验）
    3. 收集表单数据
    4. 提交（接口字段不多不少 字段名称完全对应 类型完全匹配）
    5. 后续逻辑处理（提供用户 + 重新拉去列表 + 表单重置 + 路由的跳转）

# 表单校验
1. 简单校验
    用ElementUI打开默认的配置项即可完成
2. 自定义校验
  ```js
  {
    validator: validateMobile
  }
    const validateMobile = (rule,value,cb)=>{
        if(value === '')
        {
            cb(new Error('不能为空'))
        }
        else{
            cb()
        }
    }

# 新增与编辑
1. 新增 点击新增按钮 - 跳转到新增路由 - 准备表单 - 表单校验 - 二次参数处理 - 提交新增接口 - 后续处理
2. 编辑 点击编辑按钮 - 携带id跳转到新路由 - 准备表单 - 表单校验 - 二次参数处理 - 提交编辑接口 - 后续处理

重点
1. 区分新增和编辑状态 始终用的是id 有id就代表当前是编辑状态 没有id 代表的是新增状态
    1. 有id 才获取详情接口
    2. 有id 调用更新接口 没有id 调用新接口
    3. 有id 显示编辑 没有id 显示新增
2. 点击确定调用接口除了区分状态之外，还需要区分参数
    1. 新增接口调用没有任何id
    2. 编辑更新接口调用，请求参数中附加id告诉后端我要更新谁